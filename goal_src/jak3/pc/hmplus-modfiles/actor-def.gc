(in-package goal)

;name: actor-def.gc

#|
(defbehavior dp-bipedal-init-by-other dp-bipedal ((vec vector))
  (init-enemy-collision! self)
  (logior! (-> self mask) (process-mask actor-pause))
  (vector-copy! (-> self root trans) vec)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (init-enemy! self)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (let ((nav (find-nearest-nav-mesh vec 0.0)) ;; try to find a nav mesh in the vicinity
        ;; verts for the path
        (cverts (new 'static 'inline-array vector 3
                (static-vectorm 1 0 0)
                (static-vectorm 0 1 0)
                (static-vectorm 0 0 1)
                )
          )
        )
    ;; if a nav mesh is close by, use that, otherwise use default
    (if nav
      (change-to nav self)
      (change-to *default-nav-mesh* self)
      )
    ;; allocate path
    (set! (-> self path) (new 'process 'path-control self 'path 0.0 (the entity #f) #f))
    (set! (-> self path curve cverts) cverts)
    (set! (-> self path curve num-cverts) 3)
    )
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (set! (-> self hit-points) (+ (-> self enemy-info default-hit-points) 35.0))
  (go-idle self)
  )|#
#|
  (define extra-offthetop 0.0)
    (define draw-levelup-noto #f)
    (define lvli 0)
    (define *xp-gain* 0.0)
    (define xp-draw #t)
    (define xpi 0)
    (define enemy-noto 0)
    (define start-was-uprising #f)
    (define wasi 0)

  (define matt-str (new 'global 'string 2048 (the-as string #f)))
  (define *pc-encoded-matt-str* (new 'global 'string 2048 (the-as string #f)))

  (define notoriety-level 0)
  (define melee-level 0)
  (define guns-level 0)
  (define eco-level 0)

  (define in-debug? #t)

  (define bm-string "")
  (define gm-string "")
  (define sq-string "")
  (define max-modg 5)
  (define max-modb 3)
  (define uni-count1 #f)
  (define uni 0)
  (define in-modifiers? #f)
  (define in-gunmods? #f)
  (define in-superpowers? #f)
  (define in-skill? #f)
  (define on-vehicle? #f)

  (define menu-slot 0)
  (define menu-type 0)
  (define menu-select 0)

  (define in-menu? #f)

  (define has-boost-tap? #f)
  (define has-fast-attacks? #f)
  (define has-luck-stat? #f)
  (define has-triple-jump? #f)
  (define has-flight-boost? #f)
  (define has-enemy-hp? #f)
  (define has-ambush? #f)
  (define has-more-enemies? #f)
  (define camera-locked? #f)
  |#


(defenum artifact-type
  :type uint8
  (artifact-a)
  (artifact-b)
  (artifact-c)
  (artifact-d)
  )

(deftype artifact-info (structure)
  ((pos            vector  :inline)
   (time           uint32)
   (artifact-type  artifact-type)
   )
  )

(defskelgroup skel-was-artifact was-artifact was-artifact-lod0-jg was-artifact-idle-ja
              ((was-artifact-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-pre-artifact-a pre-artifact-a pre-artifact-a-lod0-jg pre-artifact-a-idle-ja
              ((pre-artifact-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-pre-artifact-b pre-artifact-b pre-artifact-b-lod0-jg pre-artifact-b-idle-ja
              ((pre-artifact-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-pre-artifact-c pre-artifact-c pre-artifact-c-lod0-jg pre-artifact-c-idle-ja
              ((pre-artifact-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-pre-artifact-d pre-artifact-d pre-artifact-d-lod0-jg pre-artifact-d-idle-ja
              ((pre-artifact-d-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-gauntlets gauntlets gauntlets-lod0-jg gauntlets-idle-ja
              ((gauntlets-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(deftype was-artifact (process-drawable)
  ((root  collide-shape :override)
   (pos   vector         :inline)
   (angs  vector         :inline)
   )
  (:state-methods
    idle
    sink
    die
    )
  (:methods
    (find-ground (_type_) symbol)
    (check-pickup (_type_) none)
    (rotate (_type_) none)
    )
  )


(defmethod find-ground ((this was-artifact))
  (let ((s4-0 #f))
    (let ((gp-0 (new 'stack-no-clear 'cquery-with-vec)))
      (set! (-> gp-0 vec0 quad) (-> this root trans quad))
      (set! (-> gp-0 cquery start-pos quad) (-> gp-0 vec0 quad))
      (+! (-> gp-0 cquery start-pos y) 40960.0)
      (vector-reset! (-> gp-0 vec1))
      (set! (-> gp-0 vec1 y) 1.0)
      (set-vector! (-> gp-0 cquery move-dist) 0.0 -81920.0 0.0 1.0)
      (let ((v1-6 (-> gp-0 cquery)))
        (set! (-> v1-6 radius) 1024.0)
        (set! (-> v1-6 collide-with) (collide-spec backgnd))
        (set! (-> v1-6 ignore-process0) #f)
        (set! (-> v1-6 ignore-process1) #f)
        (set! (-> v1-6 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> v1-6 action-mask) (collide-action solid))
        )
      (let ((f0-8 (fill-and-probe-using-line-sphere *collide-cache* (-> gp-0 cquery))))
        (when (>= f0-8 0.0)
          (vector+float*! (-> gp-0 vec0) (-> gp-0 cquery start-pos) (-> gp-0 cquery move-dist) f0-8)
          (set! (-> gp-0 vec1 quad) (-> gp-0 cquery best-other-tri normal quad))
          (set! s4-0 #t)
          (format #t "was-artifact::find-ground: ground y ~M~%" (-> gp-0 vec0 y))
          )
        )
      (set! (-> this root trans quad) (-> gp-0 vec0 quad))
      (forward-up-nopitch->quaternion (-> this root quat) (new 'static 'vector :z 1.0 :w 1.0) (-> gp-0 vec1))
      )
    s4-0
    )
  )

(defmethod check-pickup ((this was-artifact))
  (let ((v1-0 *target*)
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (when v1-0
      (set! (-> s5-0 quad) (-> v1-0 control trans quad))
      (set! (-> s5-0 w) 4096.0)
      (when (focus-test? v1-0 pilot)
        (let ((a1-4 (handle->process (-> v1-0 pilot vehicle))))
          (set! (-> s5-0 quad)
                (-> (the-as collide-shape (-> (the-as process-drawable a1-4) root)) root-prim prim-core world-sphere quad)
                )
          )
        )
      (let ((f0-1 (vector-vector-xz-distance-squared (-> this root trans) s5-0))
            (f1-2 (fabs (- (-> s5-0 y) (-> this root trans y))))
            (f2-2 (+ 8192.0 (-> s5-0 w)))
            )
        (when (and (>= (* f2-2 f2-2) f0-1) (< f1-2 32768.0))
          (sound-play "artifact-pickup")
          (+! (-> *game-info* counter) -1.0)
          (when (= desert-spawn-mission-oasis #t)
            (task-node-close! (game-task-node desert-spawn-task-oasis-goto-artifact) #t)
          )
          (when (= desert-spawn-mission-deserta #t)
            (task-node-close! (game-task-node desert-spawn-task-deserta-goto-artifact) #t)
          )
          (when (= desert-spawn-mission-brute #t)
            (boss-brute! (-> this root trans))
            (set! in-satbattle? #t)
            (set! desert-spawn-mission-brute #f)
          )
          (go (method-of-object this die))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod rotate ((this was-artifact))
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (set! (-> gp-0 fvec x) (seconds-per-frame))
    (+! (-> this angs x) (* 32768.0 (-> gp-0 fvec x)))
    (+! (-> this angs y) (* 23665.777 (-> gp-0 fvec x)))
    (+! (-> this angs z) (* 20024.889 (-> gp-0 fvec x)))
    (+! (-> this angs w) (* 22755.555 (-> gp-0 fvec x)))
    (dotimes (v1-5 4)
      (if (< 32768.0 (-> this angs data v1-5))
          (+! (-> this angs data v1-5) -65536.0)
          )
      (if (< (-> this angs data v1-5) -32768.0)
          (+! (-> this angs data v1-5) 65536.0)
          )
      )
    (vector-reset! (-> gp-0 rvec))
    (set! (-> gp-0 rvec y) (+ 4915.2 (* 2048.0 (sin (-> this angs x)))))
    (set! (-> gp-0 rvec x) (* 1024.0 (sin (-> this angs y))))
    (set! (-> gp-0 rvec z) (* 1024.0 (cos (-> this angs y))))
    (vector+! (-> this root trans) (-> this pos) (-> gp-0 rvec))
    (vector-reset! (-> gp-0 uvec))
    (set! (-> gp-0 uvec z) (* 5461.3335 (sin (-> this angs z))))
    (set! (-> gp-0 uvec y) (-> this angs w))
    (quaternion-zxy! (-> this root quat) (-> gp-0 uvec))
    )
  (ja-post)
  0
  (none)
  )

(defstate idle (was-artifact)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('sink)
       (go-virtual sink)
       )
      )
    )
  :trans (behavior ()
    (check-pickup self)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
      (let ((v1-0 (new 'stack-no-clear 'vector)))
        (set! (-> v1-0 quad) (-> self root trans quad))
        (set! (-> gp-0 pos quad) (-> v1-0 quad))
        )
      (quaternion-identity! (-> gp-0 quat))
      (set! (-> gp-0 flags) (task-arrow-flags))
      (add-icon! *minimap* self (the-as uint 13) (the-as int #f) (the-as vector #t) 0)
      )
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (rotate self)
    )
  )

(defstate sink (was-artifact)
  :virtual #t
  :trans (behavior ()
    (check-pickup self)
    (+! (-> self pos y) (* -1024.0 (seconds-per-frame)))
    )
  :code (behavior ()
    (cond
      ((logtest? (-> *part-group-id-table* 333 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 333))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 333))
        )
      )
    (set-time! (-> self state-time))
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (rotate self)
    )
  )

(defstate die (was-artifact)
  :virtual #t
  :code (behavior ()
    (cleanup-for-death self)
    )
  )

  (defbehavior was-artifact-init-by-other was-artifact ((arg0 artifact-info))
  (when (task-node-open? (game-task-node desert-artifact-race-1-race))
    (set! (-> self level) (level-get *level* 'desrace1))
  )
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-8 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 transform-index) 0)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-8)
      )
    (set! (-> s5-0 nav-radius) 16384.0)
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (let ((v1-13 (-> self root root-prim)))
    (set! (-> v1-13 prim-core collide-as) (collide-spec))
    (set! (-> v1-13 prim-core collide-with) (collide-spec))
    )
  0
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (set! *spawn-vec* (-> self root trans))
  (quaternion-identity! (-> self root quat))
  (set-vector! (-> self root scale) 3.0 3.0 3.0 1.0)
  (find-ground self)
  (set! (-> self pos quad) (-> self root trans quad))
  (let* ((v1-23 (-> arg0 artifact-type))
         (a1-6 (cond
                 ((= v1-23 (artifact-type artifact-a))
                  (art-group-get-by-name *level* "skel-pre-artifact-a" (the-as (pointer level) #f))
                  )
                 ((= v1-23 (artifact-type artifact-b))
                  (art-group-get-by-name *level* "skel-pre-artifact-b" (the-as (pointer level) #f))
                  )
                 ((= v1-23 (artifact-type artifact-c))
                  (art-group-get-by-name *level* "skel-pre-artifact-c" (the-as (pointer level) #f))
                  )
                 ((= v1-23 (artifact-type artifact-d))
                  (art-group-get-by-name *level* "skel-pre-artifact-d" (the-as (pointer level) #f))
                  )
                 (else
                   (art-group-get-by-name *level* "skel-gauntlets" (the-as (pointer level) #f))
                   )
                 )
               )
         )
    (initialize-skeleton self (the-as skeleton-group a1-6) (the-as pair 0))
    )
  (if (-> self draw shadow)
      (set! (-> self draw shadow-ctrl) (new
                                         'process
                                         'shadow-control
                                         -12288.0
                                         12288.0
                                         614400.0
                                         (the-as vector #f)
                                         (shadow-flags shdf00 shdf04)
                                         245760.0
                                         )
            )
      )
  (let ((a0-31 (find-nearest-nav-mesh (-> self pos) (the-as float #x7f800000))))
    (if a0-31
        (add-process-drawable-to-nav-mesh a0-31 self #f)
        )
    )
  (go-virtual idle)
  )

  ;; WARN: Return type mismatch process vs was-artifact.
(defun was-artifact-spawn ((arg0 process) (arg1 artifact-info))
  (let ((gp-0 (the-as process #f)))
    (let ((v1-1 (process-spawn was-artifact arg1 :name "was-artifact" :to arg0)))
      (if v1-1
          (set! gp-0 (-> v1-1 0))
          )
      )
    (the-as was-artifact gp-0)
    )
  )

  (defun spawn-artifact ((vec vector))
    (let ((gp-0 (new 'static 'artifact-info)))
        (set! (-> gp-0 pos quad) (-> vec quad))
        (set! (-> gp-0 time) (seconds 0.0))
        (let ((rnd (rand-vu-int-range 1 4)))
                (when (= rnd 1)
                    (set! (-> gp-0 artifact-type) (artifact-type artifact-a))
                )
                (when (= rnd 2)
                    (set! (-> gp-0 artifact-type) (artifact-type artifact-b))
                )
                (when (= rnd 3)
                    (set! (-> gp-0 artifact-type) (artifact-type artifact-c))
                )
                (when (= rnd 4)
                    (set! (-> gp-0 artifact-type) (artifact-type artifact-d))
                )
            )
        (process-spawn was-artifact gp-0 :name "was-artifact" :from *default-dead-pool* :stack-size #x18000)
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
